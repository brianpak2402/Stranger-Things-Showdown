#include "main.h"
#include "src/screens.h"
#include "src/images.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not required to use
// these specific provided states.
enum gba_state {
  START,                      // the beginning of the game
  START_INPUT,                // handles button inputs after start screen shows
  PLAYER_SELECT_DRAW,         // draws out the player selection screen
  PLAYER_SELECT_INPUT,        // handles button inputs for player select
  OPPONENT_SELECT_DRAW,       // draws out the opponent selection screen
  OPPONENT_SELECT_INPUT,      // handles button inputs
  PLAY_DRAW,                  // draws out the "arena" for the game
  PLAY_INPUT,                 // handles movement inputs around the arena
  CHOICE_DRAW,                // draws out choices into the arena 
  CHOICE_INPUT,               // handles player moving towards their choice and handles collision
  END,                        // shows results
};


int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. 
  REG_DISPCNT = MODE3 | BG2_ENABLE;

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;

  // Initialize cursor for player select
  struct selector player_selector;


  while (1) {
    waitForVBlank();
    currentButtons = BUTTONS; // Load the current state of the buttons
    
    switch (state) {
      case START:
        // Reset character choice whenever game restarts.
        player.character = 0;
        opponent.character = 0;

        // Draw out the screen.
        state = START_INPUT;
        buildTitleScreen();
        break;

      case START_INPUT:
        // Handle button input.
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
        }
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          // Set new state and clear the screen when START is pressed.
          state = PLAYER_SELECT_DRAW;
          fillScreenDMA(BLACK);
        }
        break;

      // Where player selects their character
      case PLAYER_SELECT_DRAW:
        // Draw out the character options. 
        buildPlayerSelect();

        player_selector.currentRow = 130;
        player_selector.currentCol = 20;
        drawRectDMA(player_selector.currentRow, player_selector.currentCol, 30, 2, WHITE);

        state = PLAYER_SELECT_INPUT;
        break;

      case PLAYER_SELECT_INPUT:
        // Handle button inputs.
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
        }
        if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons)) {
          // Move cursor right and update player's character choice.
          if (player.character != 6) {
            player.character++;
            drawRectDMA(player_selector.currentRow, player_selector.currentCol, 30, 2, BLACK);
            player_selector.currentCol += 30;
          }
          drawRectDMA(player_selector.currentRow, player_selector.currentCol, 30, 2, WHITE);
        } 
        if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons)) {
          // Move cursor left and update player's character choice.
          if (player.character != 0 && player.character < 7) {
            player.character--;
            drawRectDMA(player_selector.currentRow, player_selector.currentCol, 30, 2, BLACK);
            player_selector.currentCol -= 30;
          }
          drawRectDMA(player_selector.currentRow, player_selector.currentCol, 30, 2, WHITE);
        }
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          // Proceed to the next state once START is pressed.
          state = OPPONENT_SELECT_DRAW;
          fillScreenDMA(BLACK);
        }
        break;

      // Where player selects their opponent
      case OPPONENT_SELECT_DRAW:
        // Draw out the screen
        buildOpponentSelect();

        // Draw out the player selector, a cursor for selecting characters.
        player_selector.currentRow = 130;
        player_selector.currentCol = 20;
        drawRectDMA(player_selector.currentRow, player_selector.currentCol, 30, 2, WHITE);

      
        state = OPPONENT_SELECT_INPUT;
        break;

      case OPPONENT_SELECT_INPUT:
        // Handle button inputs.
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
        }
        if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons)) {
          // Move cursor right and update opponent's character choice.
          if (opponent.character != 6) {
            opponent.character++;
            drawRectDMA(player_selector.currentRow, player_selector.currentCol, 30, 2, BLACK);
            player_selector.currentCol += 30;
          }
          drawRectDMA(player_selector.currentRow, player_selector.currentCol, 30, 2, WHITE);
        } 
        if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons)) {
          // Move cursor left and update opponent's character choice.
          if (opponent.character != 0 && opponent.character < 7) {
            opponent.character--;
            drawRectDMA(player_selector.currentRow, player_selector.currentCol, 30, 2, BLACK);
            player_selector.currentCol -= 30;
          }
          drawRectDMA(player_selector.currentRow, player_selector.currentCol, 30, 2, WHITE);
        }
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          // Proceed to PLAY stage once player selects their opponent.
          state = PLAY_DRAW;
        }
        break;

      // The actual game itself.
      case PLAY_DRAW:
        // Setup background.
        drawFullScreenImageDMA(DesertField);
        state = PLAY_INPUT;

        // Setup player and opponent characters
        player.currentRow = 60;
        player.currentCol = 30;
        drawImageDMA(player.currentRow, player.currentCol, 30, 30, pickCharacter(player.character));

        opponent.currentRow = 60;
        opponent.currentCol = 180;
        drawImageDMA(opponent.currentRow, opponent.currentCol, 30, 30, pickCharacter(opponent.character));
        
        // Draw instructions.
        drawCenteredString(120, 0, WIDTH, 30, "Approach your opponent.", BLACK);

        // Reset player's and opponent's choice.
        opponent.choice = (rand() % (2 - 0 + 1));
        player.choice = 0;
        break;

      case PLAY_INPUT: 

        // Handle button inputs
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
        }

        // Handle movement inputs.
        if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons)) {
          // Check if player is within bounds.
          if (player.currentCol <= 200) {
            undrawImageDMA(player.currentRow, player.currentCol, 30, 30, DesertField);
            player.currentCol += 5;
          }
          // Draw the player in their new position (if they are within bounds).
          drawImageDMA(player.currentRow, player.currentCol, 30, 30, pickCharacter(player.character));
        }
        if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons)) {
          if (player.currentCol >= 10) {
            undrawImageDMA(player.currentRow, player.currentCol, 30, 30, DesertField);
            player.currentCol -= 5;
          }
          drawImageDMA(player.currentRow, player.currentCol, 30, 30, pickCharacter(player.character));
        }
        if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons)) {
          if (player.currentRow >= 5) {
            undrawImageDMA(player.currentRow, player.currentCol, 30, 30, DesertField);
            player.currentRow -= 5;
          }
          drawImageDMA(player.currentRow, player.currentCol, 30, 30, pickCharacter(player.character));
        }
        if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons)) {
          if (player.currentRow <= 155) {
            undrawImageDMA(player.currentRow, player.currentCol, 30, 30, DesertField);
            player.currentRow += 5;
          }
          drawImageDMA(player.currentRow, player.currentCol, 30, 30, pickCharacter(player.character));
        }

        // Handle player meeting with opponent.
        if ((player.currentCol >= opponent.currentCol - 30) 
              && ((player.currentRow >= opponent.currentRow - 30) && player.currentRow <= opponent.currentRow)) {
          state = CHOICE_DRAW;
        }
        break;

      case CHOICE_DRAW:
        // Redraw instructions.
        undrawImageDMA(120, 0, WIDTH, 30, DesertField);
        drawCenteredString(130, 0, WIDTH, 30, "Approach your choice.", BLACK);

        // Draw out the choices.
        drawImageDMA(20, 40, 30, 30, Rock);
        drawImageDMA(60, 40, 30, 30, Paper);
        drawImageDMA(100, 40, 30, 30, Scissors);

        // Proceed to the next state to handle button inputs.
        state = CHOICE_INPUT;
        break;

      case CHOICE_INPUT:
        // Return to beginning of game if SELECT is pressed.
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
        }

        // Store previous location for collision handling
        player.previousRow = player.currentRow;
        player.previousCol = player.currentCol;

        // Handle movement inputs and possible collision between player and opponent.
        if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons)) {
          // Check if player is within bounds.
          if (player.currentCol <= 200) {
            // Undraw the player's character and set new position.
            undrawImageDMA(player.currentRow, player.currentCol, 30, 30, DesertField);
            player.currentCol += 5;
          }
          if ( (player.currentRow <= opponent.currentRow + 25) && (player.currentRow >= opponent.currentRow - 25)
                && (player.currentCol >= opponent.currentCol - 25)) {
            // If player and opponent will collide after movement, reset to previous position before drawing.
            player.currentCol = player.previousCol;
          }
          drawImageDMA(player.currentRow, player.currentCol, 30, 30, pickCharacter(player.character));
        }
        if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons)) {
          if (player.currentCol >= 10) {
            undrawImageDMA(player.currentRow, player.currentCol, 30, 30, DesertField);
            player.currentCol -= 5;
          }
          if ( (player.currentRow <= opponent.currentRow + 25) && (player.currentRow >= opponent.currentRow - 25)
                && (player.currentCol >= opponent.currentCol - 25)) {
            player.currentCol = player.previousCol;
          }
          drawImageDMA(player.currentRow, player.currentCol, 30, 30, pickCharacter(player.character));
        }
        if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons)) {
          if (player.currentRow >= 5) {
            undrawImageDMA(player.currentRow, player.currentCol, 30, 30, DesertField);
            player.currentRow -= 5;
          }
          if ( (player.currentRow <= opponent.currentRow + 25) && (player.currentRow >= opponent.currentRow - 25)
                && (player.currentCol >= opponent.currentCol - 25)) {
            player.currentRow = player.previousRow;
          }
          drawImageDMA(player.currentRow, player.currentCol, 30, 30, pickCharacter(player.character));
        }
        if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons)) {
          if (player.currentRow <= 155) {
            undrawImageDMA(player.currentRow, player.currentCol, 30, 30, DesertField);
            player.currentRow += 5;
          }
          if ( (player.currentRow <= opponent.currentRow + 25) && (player.currentRow >= opponent.currentRow - 25)
                && (player.currentCol >= opponent.currentCol - 25)) {
            player.currentRow = player.previousRow;
          }
          drawImageDMA(player.currentRow, player.currentCol, 30, 30, pickCharacter(player.character));
        }

        // Handle collision between player and choice.
        if (player.currentCol == 70) {
          if (player.currentRow >= 10 && player.currentRow <= 30) {
            // Handle collision between player and Rock
            player.choice = 0;
            state = END;
            drawFullScreenImageDMA(DesertField);
          } else if (player.currentRow >= 50 && player.currentRow <= 90) {
            // Handle collision between player and Paper
            player.choice = 1;
            state = END;
            drawFullScreenImageDMA(DesertField);
          } else if (player.currentRow >= 90 && player.currentRow <= 130) {
            // Handle collision between player and Scissors
            player.choice = 2;
            state = END;
            drawFullScreenImageDMA(DesertField);
          }
        }
        break;

      // Present the results of the game.
      case END:
        // Setup player and opponent characters and their choices.
        player.currentRow = 60;
        player.currentCol = 30;
        drawImageDMA(player.currentRow, player.currentCol, 30, 30, pickCharacter(player.character));
        drawImageDMA(60, 70, 30, 30, pickChoice(player.choice));

        opponent.currentRow = 60;
        opponent.currentCol = 140;
        drawImageDMA(opponent.currentRow, opponent.currentCol, 30, 30, pickCharacter(opponent.character));
        drawImageDMA(60, 180, 30, 30, pickChoice(opponent.choice));

        // Present the results with a string.
        switch (decideWinner(player.choice, opponent.choice)) {
          case 0:
            drawCenteredString(30, 0, WIDTH, 30, "TIE! Try again.", BLACK);
            break;
          case 1:
            drawCenteredString(30, 0, WIDTH, 30, "You win!", BLACK);
            break;
          default:
            drawCenteredString(30, 0, WIDTH, 30, "You lose! Better luck next time.", BLACK);
            break;
        }
        // Draw out instructions to continue or restart the game.
        drawCenteredString(90, 0, WIDTH, 30, "Press Start to finish game.", BLACK);
        drawCenteredString(110, 0, WIDTH, 30, "Press A for a rematch.", BLACK);

        // Handle button input.
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
        }
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = START;
        }
        if (KEY_JUST_PRESSED(BUTTON_A, currentButtons, previousButtons)) {
          state = PLAY_DRAW;
        }

        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }
  return 0;
}

/**
 * Helper method to draw player's/opponent's character.
 */
const unsigned short int* pickCharacter(int input) {
  switch (input) {
    case 0: 
      return Dustin;
    case 1: 
      return Mike;
    case 2: 
      return Lucas;
    case 3: 
      return Hopper;
    case 4: 
      return Will;
    case 5:
      return Eleven;
    default:
      return Nancy;
  }
} 

/**
 * Helper method to draw player's/opponent's choice.
 */
const unsigned short int* pickChoice(int input) {
  switch (input) {
    case 0:
      return Rock;
    case 1:
      return Paper;
    default:
      return Scissors;
  }
}

/**
 * Determines who wins based on the given rock (0),paper (2),scissor (3) integer representations.
 * Returns 0 if tie, 1 if player 1 wins, and 2 if player 2 wins.
 */
int decideWinner(int one, int two) {
  if (one == two) {
    return 0;
  } else if (one == 0) {
    // Possible outcomes if one picks rock.
    if (two == 1) {
      return 2;
    } else {
      return 1;
    }
  } else if (one == 1) {
    // Possible outcomes if one picks paper.
    if (two == 0) {
      return 1;
    } else {
      return 2;
    }
  } else {
    // Possible outcomes if one picks scissors.
    if (two == 0) {
      return 2;
    } else {
      return 1;
    }
  } 
}
